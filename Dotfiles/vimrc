if !has('nvim')
   " Duplicate NeoVim's changes to Vim defaults, incase I start classic Vim for some reason
   " (See :help nvim-defaults)
   filetype plugin indent on

   set autoread autoindent backspace=indent,eol,start belloff=all complete-=i display=lastline \
       history=10000 hlsearch incsearch nolangremap nocompatible nrformats=bin,hex ruler \
       sessionoptions-=options showcmd tabpagemax=50 ttyfast viminfo+=",!" wildmenu

   set encoding=utf-8
endif

set hidden
set textwidth=100 wrapmargin=3
set cursorline colorcolumn=+1,+2,+3
set number signcolumn=auto
set smarttab expandtab tabstop=8 softtabstop=3 shiftwidth=3 shiftround
set smartcase ignorecase

set nowrap
set virtualedit=block
set listchars+=tab:\ ─
set breakindent showbreak=⥟\ \   " For `set wrap linebreak`

set ignorecase smartcase gdefault

set scrolloff=3
set title

set completeopt=longest,menuone,preview

set conceallevel=1

" This is overridden in the vim-lightline configuration below.
set showtabline=2 laststatus=2 cmdheight=2 showmode

syntax on



" `vim-plug` installation & package-loading
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  au VimEnter * PlugInstall --sync | source $MYVIMRC
endif

source ~/.vim/packages.vim


if !exists('g:lightline') | let g:lightline = {} | endif

" Set the colour-scheme
if has("gui_vimr")
   colorscheme nord
   let g:lightline.colorscheme = 'nord'
else
   set background=light
   let g:seiya_auto_enable = 1
   let g:solarized_use16 = 1
   colorscheme solarized8
   let g:lightline.colorscheme = 'solarized'
endif

function! s:ResetLightlineColorscheme()
   if &background ==# 'light' && exists("g:colorschemes.lightline.light")
      g:lightline.colorscheme = g:colorschemes.lightline.light
   elseif &background ==# 'dark' && exists("g:colorschemes.lightline.dark")
      g:lightline.colorscheme = g:colorschemes.lightline.dark
   endif
endfunction

" FIXME: This is hacky, and intentionally stomps on / re-implements Lightline's own autocommands.
function! s:FixLightlineAutocommands()
   augroup lightline
      au! ColorScheme
      au  ColorScheme * call s:ResetLightlineColorscheme()
      au  ColorScheme * call lightline#update()
      au  ColorScheme * call lightline#highlight()
   augroup END
endfunction

au VimEnter * call s:FixLightlineAutocommands()

" Finally, I actually configure, and invoke, the color-switcher.
if has("gui_vimr")
   let g:colorschemes = {
    \ 'dark':  'nord',
    \ 'light': 'base16-atelier-lakeside-light',
    \ 'lightline': {
    \    'dark': 'nord',
    \    'light': 'nord'
    \ }
    \ }

   call togglebg#("dark")
else
   call togglebg#("light", "solarized8")
endif


" Command-line tab completion
set wildmode=list:longest,list:full
set wildignore+=*.o,*.obj,.git,*.class,.svn

if has("mouse")
   set mouse=a

   if !has('nvim') && &term == 'screen'
      " tmux knows the extended mouse mode
      set ttymouse=xterm2
   endif

   if !has('nvim') && v:version >= 704 && &term =~ '^screen'
      " Odds are good that this is a modern tmux, so let's pick the best mouse-handling mode.
      set ttymouse=sgr
   endif

   " These break the Markdown plugin o_O
  "map <ScrollWheelUp> <C-Y>
  "map <ScrollWheelDown> <C-E>
endif

let g:python3_host_prog = '/usr/local/bin/python3'

if executable("ag")
  "set grepprg=ag\ --nogroup\ --nocolor
   set grepprg=ag\ --vimgrep\ --nocolor
   let g:ctrlp_user_command = 'ag %s -l --nocolor --hidden -g ""'
endif

" Fill these functions to tie other plugins into focus-mode
function! s:goyo_enter()
   " ...
endfunction

function! s:goyo_leave()
   " ...
endfunction

" These autocmds self-unique, thanks to the `!`
au! User GoyoEnter nested call <SID>goyo_enter()
au! User GoyoLeave nested call <SID>goyo_leave()

"au FileType c,cpp nested :TagbarOpen
"
"
" === Styles ===
let g:solarized_visibility = "high"

" Colourize trailing whitespace
hi ShowTrailingWhitespace ctermbg=Red guibg=Red

" Obscure the iconic vim 'empty-line tildes'
" FIXME: VimR appears to reliably crash, with these?
if !has('gui_vimr')
   hi EndOfBuffer ctermbg=fg
   hi! link EndOfBuffer SignColumn
endif

"if &diff
"   let g:color_coded_enabled = 0
"endif


" === Mappings ===
" Thanks, Damian. http://ell.io/i6io1
nnoremap ; :
nnoremap ; :

nnoremap ;; ;
vnoremap ;; ;

nnoremap ,, ,
vnoremap ,, ,

" Fuck '.
nnoremap ' `
nnoremap ` '

" These make movement commands “work” with `o`, such as `3o` to insert inject lines and switch to insert mode.
"nnoremap o o<Esc>S        " ... unfortunately, they break yanking.
"nnoremap O O<Esc>'[S

" See `:help Y`
map Y y$

" Because why `j` et al step over a bajillion visible lines at a time, I cannot fathom.
nnoremap j gj
nnoremap k gk

" #### Global mappings
for map_command in ['noremap', 'noremap!', 'tnoremap']
   " When it comes to windows, I don't like how _ and = (which are related mappings) and - and +
   " (also related) require different shift-keying. Thus, I'm swapping them — unshifted '-' and '='
   " for one purpose, and shifted '_' and '+' for another.
   execute map_command . ' <silent> <C-w>- <C-\><C-n><C-w>_'
   execute map_command . ' <silent> <C-w>_ <C-\><C-n><C-w>-'
endfor

map /  <Plug>(incsearch-easymotion-/)
map ?  <Plug>(incsearch-easymotion-?)
map g/ <Plug>(incsearch-easymotion-stay)

map n  <Plug>(incsearch-nohl-n)
map N  <Plug>(incsearch-nohl-N)
map *  <Plug>(incsearch-nohl-*)
map #  <Plug>(incsearch-nohl-#)
map g* <Plug>(incsearch-nohl-g*)
map g# <Plug>(incsearch-nohl-g#)

" The global <Leader> is the spacebar. This primarily covers the EasyMotion invocations, but also
" includes some other global-plugin features.
let mapleader = " "
let maplocalleader = ","

let g:EasyMotion_do_mapping = 0
" EasyMotion stomps:
"   - fF, tT, wW, bB, eE, geE, j, k, nN, s,
"map <Leader> <Plug>(easymotion-prefix)

" I chose to stomp the non-<Leader> versions for fF and tT, but not for wW/bB/eE/geE, because it's more
" useful to spam the latter (as in `wwwww`). Theoretically, EasyMotion should *supplant* that
" behaviour; but realistically, I still use the latter thanks to muscle-memory.
nmap f <Plug>(easymotion-fl)|xmap f <Plug>(easymotion-fl)|omap f <Plug>(easymotion-fl)
nmap F <Plug>(easymotion-Fl)|xmap F <Plug>(easymotion-Fl)|omap F <Plug>(easymotion-Fl)
nmap t <Plug>(easymotion-tl)|xmap t <Plug>(easymotion-tl)|omap t <Plug>(easymotion-tl)
nmap T <Plug>(easymotion-Tl)|xmap T <Plug>(easymotion-Tl)|omap T <Plug>(easymotion-Tl)

" Since the within-line searches are handled by non-prefixed mappings above, I use the <Leader>-
" prefixed mappings for bidirectional/overwin-mode:
" mnemonic: 'sneak'
nmap <Leader>s <Plug>(easymotion-overwin-f2)
xmap <Leader>s <Plug>(easymotion-bd-f2)
omap <Leader>s <Plug>(easymotion-bd-f2)

" This makes <Leader>-k and <Leader>-b a little inconsistent, but I prefer the extra mapping-
" mnemonic space.
nmap <Leader>j <Plug>(easymotion-overwin-line)
xmap <Leader>j <Plug>(easymotion-bd-jk)
omap <Leader>j <Plug>(easymotion-bd-jk)
"nmap <Leader>k <Plug>(easymotion-overwin-line)
"xmap <Leader>k <Plug>(easymotion-bd-jk)
"omap <Leader>k <Plug>(easymotion-bd-jk)

" And finally, since `w` and `e` match so many words, especially bidirectionally, I leave them
" prefixed *and* window-bound.
nmap <Leader>w <Plug>(easymotion-bd-w)
xmap <Leader>w <Plug>(easymotion-bd-w)
omap <Leader>w <Plug>(easymotion-bd-w)
"nmap <Leader>b <Plug>(easymotion-bd-w)
"xmap <Leader>b <Plug>(easymotion-bd-w)
"omap <Leader>b <Plug>(easymotion-bd-w)

" <Space><Space> → jump-to-anywhere
map <Leader><Leader> <Plug>(easymotion-lineanywhere)


nmap <Leader>n <Plug>(easymotion-bd-n)
xmap <Leader>n <Plug>(easymotion-bd-n)
omap <Leader>n <Plug>(easymotion-bd-n)

" Even though I've discarded the non-<Leader> versions of these, the classic mnemonic is memorable
nmap <Leader>; <Plug>(easymotion-next)
nmap <Leader>, <Plug>(easymotion-prev)

" Complete an EasyMotion by hitting <Space> again
augroup easymotion-keymap | au!
   au VimEnter * EMCommandLineNoreMap <Space> <CR>
augroup END


"noremap  <silent> <F1>          :<C-u>NERDTreeTabsToggle<Return>
"inoremap <silent> <F1>     <C-O>:<C-u>NERDTreeTabsToggle<Return>
"vnoremap <silent> <F1>     <Esc>:<C-u>NERDTreeTabsToggle<Return>
"noremap  <silent> <F2>          :<C-u>GundoToggle<Return>
"inoremap <silent> <F2>     <C-O>:<C-u>GundoToggle<Return>
"vnoremap <silent> <F2>     <Esc>:<C-u>GundoToggle<Return>
"noremap  <silent> <F3>          :<C-u>TagbarToggle<Return>
"inoremap <silent> <F3>     <C-O>:<C-u>TagbarToggle<Return>
"vnoremap <silent> <F3>     <Esc>:<C-u>TagbarToggle<Return>

noremap  <silent> <F8>          :<C-u>set spell!<Return>
inoremap <silent> <F8>     <C-O>:<C-u>set spell!<Return>
vnoremap <silent> <F8>     <Esc>:<C-u>set spell!<Return>

call togglebg#map("<Leader>bg")

" F9 to toggle focus-mode
nmap <silent> <F9>  :Goyo<cr>
imap <silent> <F9>  <C-O><F9>

" F11 to toggle the signcolumn (‘gutter’)
nmap <silent> <F11> :exec &signcolumn == "no" ? "set signcolumn=yes" : "set signcolumn=no"<cr>
imap <silent> <F11> <C-O><F11>

" F12 to toggle hilight, Shift-F12 to clear search register
nmap <silent> <F12> :silent set invhls<CR>
imap <silent> <F12> <C-O><F12>
map  <silent> <S-F12> :let @/ = @_<CR>
imap <silent> <S-F12> <C-O><S-F12>

" Toggle conealing with <Space>-c
map <Leader>c :exec &conceallevel ? "set conceallevel=0" : "set conceallevel=1"<CR>

" Toggle highlighting of trailing whitespace with <Space>-s4
" mnemonic: 'whiteZpace'
nnoremap <silent> <Leader>zs :<C-u>call ShowTrailingWhitespace#Toggle(0)<Bar>echo (ShowTrailingWhitespace#IsSet() ? 'Show trailing whitespace' : 'Not showing trailing whitespace')<CR>
nnoremap <silent> <Leader>zx :DeleteTrailingWhitespace<CR>

" <Ctrl-P> for both switching between buffers, and opening new ones!
nnoremap <C-p>             :<C-u>Denite -source-names=hide buffer file_rec<CR>

nnoremap <Leader>d         :<C-u>DeniteBufferDir file_rec<CR>
"nnoremap <Leader>ss        :<C-u>DeniteBufferDir buffer<CR>

nnoremap <Leader>/         :<C-u>Denite grep:. -mode=normal<CR>
nnoremap <Leader>8         :<C-u>DeniteCursorWord grep:. -mode=normal<CR>
nnoremap <Leader>*         :<C-u>DeniteCursorWord grep:. -mode=normal<CR>

"nnoremap <Leader>o         :<C-u>Denite location_list -mode=normal -no-empty<CR>
"nnoremap <Leader>hs        :<C-u>Denite history:search -mode=normal<CR>
"nnoremap <Leader>hc        :<C-u>Denite history:cmd -mode=normal<CR>

nnoremap <Leader><F1>      :<C-u>Denite help<CR>


" Mappings in Denite modals
call denite#custom#map('insert', '<Esc>', '<denite:enter_mode:normal>',          'noremap')
call denite#custom#map('normal', '<Esc>', '<NOP>',                               'noremap')

call denite#custom#map('insert', '<CR>',  '<denite:do_action:switch>',           'noremap')
call denite#custom#map('normal', '<CR>',  '<denite:do_action:switch>',           'noremap')

call denite#custom#map('_',      '<C-t>', '<denite:do_action:tabswitch>',        'noremap')
call denite#custom#map('insert', '<C-t>', '<denite:do_action:tabswitch>',        'noremap')

call denite#custom#map('_',      '<C-s>', '<denite:do_action:splitswitch>',      'noremap')
call denite#custom#map('_',      '<C-v>', '<denite:do_action:vsplitswitch>',     'noremap')
call denite#custom#map('insert', '<C-v>', '<denite:do_action:vsplitswitch>',     'noremap')


" (Chosen to match the easymotion-bd-jk mapping)
call denite#custom#map('normal', '<Leader>j', '<denite:quick_move>',             'noremap')

call denite#custom#map('insert', '<C-j>', '<denite:move_to_next_line>',          'noremap')
call denite#custom#map('normal', '<C-j>', '<denite:move_to_next_line>',          'noremap')
call denite#custom#map('insert', '<C-k>', '<denite:move_to_previous_line>',      'noremap')
call denite#custom#map('normal', '<C-k>', '<denite:move_to_previous_line>',      'noremap')

call denite#custom#map('insert', '<C-n>', '<denite:assign_next_matched_text>',   'noremap')
call denite#custom#map('insert', '<C-p>', '<denite:assign_previous_matched_text>', 'noremap')

" ... w...why are these missing ...
call denite#custom#map('normal', 'dw',    '<denite:delete_word_after_caret>',    'noremap')
call denite#custom#map('normal', '^',     '<denite:move_caret_to_lead>',         'noremap')

" Prevent UltiSnips from stomping on <C-j/k>
let g:UltiSnipsExpandTrigger="<Tab>"
let g:UltiSnipsJumpForwardTrigger="<C-b>"
let g:UltiSnipsJumpBackwardTrigger="<C-z>"

" Make Denite results less fugly
hi link deniteMatchedChar Special

" Write files, by default
augroup focus-loss-auto-write | au!
   au BufLeave,FocusLost * silent! wall
augroup END

"" gist-vim defaults
"if has("mac")
"  let g:gist_clip_command = 'pbcopy'
"elseif has("unix")
"  let g:gist_clip_command = 'xclip -selection clipboard'
"endif
"let g:gist_detect_filetype = 1
"let g:gist_open_browser_after_post = 1

set undofile
set undolevels=10000

" Directories for swp files
set backupdir=~/.vim/backup
set directory=~/.vim/backup
set undodir=~/.vim/undo,\ .

" suggested by vim-gitgutter
set updatetime=250

"set statusline=%<%f\ %h%m%r%{fugitive#statusline()}%=%-14.(%l,%c%V%)\ %P

"" The markdown.vim ftplugin supports ```this kind of syntax-hilighting fence
"let g:markdown_fenced_languages = [ 'c', 'objc', 'make', 'sh'
"                                 \, 'html', 'css', 'xml'
"                                 \, 'js=javascript', 'coffee', 'json'
"                                 \, 'ruby', 'python', 'lisp', 'scheme', 'haskell' ]


" === Filetype extension ===
augroup filetypes | au!
   au BufNewFile,BufFilePre,BufRead *.md
    \ set filetype=markdown

   au BufNewFile,BufFilePre,BufRead {Gemfile,Rakefile,Vagrantfile,Thorfile,config.ru}
    \ set filetype=ruby

   au BufNewFile,BufFilePre,BufRead *.pegjs
    \ set filetype=pegjs

   au BufNewFile,BufFilePre,BufRead {.profile,.zprofile,.zlogin,.zlogout,.zshrc,.zshenv}
    \ set filetype=zsh

   " Like, I'm supposed to put these in separate files, but lol no thx?
   au FileType gitcommit set wrap tw=0

   " To fold by indentation in CoffeeScript files, but don't enable by default. (`zi` to enable)
   au BufNewFile,BufReadPost *.coffee setl foldmethod=indent nofoldenable
augroup END


augroup ocamlmaps | au!
   au FileType ocaml nmap <LocalLeader>*   <Plug>(MerlinSearchOccurrencesForward)
   au FileType ocaml nmap <LocalLeader>#   <Plug>(MerlinSearchOccurrencesBackward)
   au FileType ocaml nmap <LocalLeader>r   <Plug>(MerlinRename)
   au FileType ocaml nmap <LocalLeader>R   <Plug>(MerlinRenameAppend)

   " I don't know why Merlin doesn't ship with a mapping for these.
   au FileType ocaml nmap <LocalLeader>y  :MerlinYankLatestType<cr>
   au FileType ocaml nmap <LocalLeader>l  :MerlinLocate<cr>

augroup END

" FIXME: idk how to make these non-global, though. They should really be au-filetype'd.
let g:merlin_textobject_grow   = 'm'
let g:merlin_textobject_shrink = 'M'


"" === Plugins ===
" #### Startify
if getcwd() ==# $HOME
   let g:startify_list_order = [
    \    ['Recent files:'], 'files',
    \    ['Bookmarks:'], 'bookmarks',
    \    ['Sessions:'], 'sessions',
    \    ['Shortcuts:'], 'commands'   ]
   let g:startify_files_number = 20
else
   let g:startify_list_order = [
    \    ['Recent files in current directory:'], 'dir',
    \    ['Recent files elsewhere:'], 'files',
    \    ['Bookmarks:'], 'bookmarks',
    \    ['Sessions:'], 'sessions',
    \    ['Shortcuts:'], 'commands'   ]
   let g:startify_files_number = 10
endif
let g:startify_bookmarks = [ '~/.vimrc', '~/.zshrc' ]
let g:startify_commands = [ ':help reference', ':PlugUpdate' ]

let g:startify_skiplist = [
 \    'COMMIT_EDITMSG',
 \    escape(fnamemodify(resolve($VIMRUNTIME), ':p'), '\') .'doc',
 \    '/usr/local/Cellar/neovim/.*/runtime/doc',
 \    'plugged/.*/doc',
 \ ]

let g:startify_fortune_use_unicode = 1
let g:startify_update_oldfiles = 1
let g:startify_change_to_dir = 0
let g:startify_change_to_vcs_root = 1
let g:startify_use_env = 1

let g:startify_custom_indices = ['a', 'd', 'f', 'h', 'l', 'w', 'r', 'y', 'o', 'p', 'z', 'x', 'c',
 \ 'b', 'n', 'm', ',', 'A', 'D', 'F', 'H', 'L', 'W', 'R', 'Y', 'O', 'P', 'Z', 'X', 'C', 'B', 'N']

" #### Goyo
let g:goyo_width = 100

" #### Denite
call denite#custom#option('_', {
 \    'prompt':         '❯'
 \  , 'auto_resize':    v:true
 \  , 'ignorecase':     v:false
 \  , 'smartcase':      v:true
 \  , 'source_names':   'short'
 \  , 'statusline':     v:false
 \ })

" Ripgrep 4 lyfe!
call denite#custom#var('file_rec', 'command', ['rg', '--files', '--glob', '!.git'])
call denite#custom#var('grep',     'command', ['rg'])
call denite#custom#var('grep',     'default_opts', ['--hidden', '--vimgrep', '--no-heading', '-S'])
call denite#custom#var('grep',     'recursive_opts', [])
call denite#custom#var('grep',     'final_opts',   [])

" Disable the vim-devicons plugin, as it's rather broken:
let g:webdevicons_enable_denite = 0

" #### EasyMotion
let g:EasyMotion_prompt = '❯ '
let g:EasyMotion_enter_jump_first = 1

" `ff` will include 'F' in the options, `f\` will include '|', etc.
let g:EasyMotion_smartcase = 1
let g:EasyMotion_use_smartsign_us = 1

" All matches will be upper-case ('S'), but the lower-case key will jump to them ('s')
let g:EasyMotion_use_upper = 1
let g:EasyMotion_keys = 'ASDGHKLQWERTYUIOPZXCVBNMFJ;'   " The defaults, capitalized for use_upper

" #### incsearch.vim
let g:incsearch#auto_nohlsearch = 1
let g:incsearch#consistent_n_direction = 1
let g:incsearch#do_not_save_error_message_history = 1

let g:incsearch#magic = '\v' " very magic

"let NERDChristmasTree = 1
"let NERDTreeShowBookmarks = 1
"let NERDTreeBookmarksFile = '.NERDTreeBookmarks'
"let NERDTreeMouseMode = 2
"let NERDTreeSortOrder = ['\/$', '\.h$', '*']
"let NERDTreeWinPos = 'right'
"let NERDTreeMinimalUI = 1
"let NERDTreeDirArrows = 1
"let NERDTreeWinSize = 25
"
"let NERDBlockComIgnoreEmpty = 0
"let NERDSpaceDelims = 1
"let NERDCompactSexyComs = 1
"let NERDDefaultNesting = 0
"
"let g:CommandTMaxCachedDirectories = 0
"let g:CommandTMaxHeight = 10
"let g:CommandTMatchWindowReverse = 1
"let g:CommandTScanDotDirectories = 1  " `:set wildignore` handles this better.
"
""let g:CoffeeAutoTagIncludeVars=1
"
"" #### vim-javascript
"let g:javascript_plugin_jsdoc = 1
"let g:javascript_plugin_flow  = 1
"
"let g:javascript_conceal_function         = "ƒ"
"let g:javascript_conceal_this             = "@"
"let g:javascript_conceal_arrow_function   = "⇒"


" #### lightline.vim
if !exists('g:lightline') | let g:lightline = {} | endif
if !exists('g:lightline.enable') | let g:lightline.enable = {} | endif

" VimR already has a GUI buffer-explorer built-in
" FIXME: VimR uses the built-in tabline; I'd really like this to switch from a bufline to a
" traditional tabline, but *keep it themed by Lightline*, if possible.
if has('gui_vimr')
   set showtabline=1
   let g:lightline.enable.tabline = 0
endif

function! FixConfigurationForLightline()
   if !exists('g:loaded_lightline')
      call denite#custom#option('_', 'statusline', v:true)
   else
      set laststatus=2 cmdheight=1 noshowmode
   endif
endfunction

augroup fix-lightline | au!
   au VimEnter * call FixConfigurationForLightline()
augroup END

let g:lightline.active = {
 \    'left':  [  ['mode', 'paste'],
 \                ['bufnum', 'filename', 'readonly',  'modified']  ],
 \    'right': [  ['charvaluehex', 'lineinfo'],
 \                ['percent'],
 \                ['fileencoding', 'fileformat', 'filetype']  ]
 \ }
let g:lightline.inactive = {
 \    'left':  [  [ 'bufnum', 'filename' ]  ],
 \    'right': [  [ 'lineinfo' ],
 \                [ 'percent' ]  ],
 \ }

let g:lightline.tabline = {
 \    'left':  [  ['bufferinfo'], ['separator'],
 \                ['bufferbefore', 'buffercurrent', 'bufferafter']   ],
 \    'right': [  ['close']  ],
 \ }
let g:lightline.tab = {
 \    'active':   ['tabnum', 'filename', 'modified'],
 \    'inactive': ['tabnum', 'filename', 'modified'],
 \ }

"let g:lightline.separator =           { 'left': "\uE0B0", 'right': "\uE0B2" } " angles
"let g:lightline.separator =           { 'left': "\u259B", 'right': "\u259F" } " OCR
let g:lightline.separator =            { 'left': "\u2590\u2595", 'right': "\u258F\u258C" } " blocks

let g:lightline.subseparator =         { 'left': "\uFE19", 'right': "\uFE19" } " vert ellipsis
"let g:lightline.subseparator =        { 'left': "\u259E", 'right': "\u259E" } " OCR
"let g:lightline.subseparator =        { 'left': "\u276F", 'right': "\u276E" } " angle brackets
"let g:lightline.subseparator =        { 'left': "\u00A6", 'right': "\u00A6" } " broken bar

let g:lightline.tabline_separator =    {}
let g:lightline.tabline_subseparator = {}

let g:lightline.component = {
 \    'charvaluehex': "%2B",
 \    'lineinfo': "\uE0A1%-3l\uE0A3%-2v",
 \ }
let g:lightline.component_expand = {
 \    'buffercurrent':  'lightline#buffer#buffercurrent',
 \    'bufferbefore':   'lightline#buffer#bufferbefore',
 \    'bufferafter':    'lightline#buffer#bufferafter',
 \ }
let g:lightline.component_type = {
 \    'buffercurrent':  'tabsel',
 \    'bufferbefore':   'raw',
 \    'bufferafter':    'raw',
 \ }
let g:lightline.component_function = {
 \    'mode':        'LightlineMode',
 \    'readonly':    'LightlineReadonly',
 \    'modified':    'LightlineModified',
 \    'fileencoding': 'LightlineFileencoding',
 \    'fileformat':  'LightlineFileformat',
 \    'filetype':    'LightlineFiletype',
 \    'bufferinfo':  'lightline#buffer#bufferinfo',
 \ }

let g:lightline.component_visible_condition = {
 \    'modified': '(&modified||!&modifiable)&&!IsWeirdBuffer()',
 \    'readonly': '&readonly&&!IsWeirdBuffer()',
 \    'paste': '&paste',
 \    'spell': '&spell',
 \    'fileencoding': '!IsWeirdBuffer()',
 \    'fileformat': '!IsWeirdBuffer() && winwidth(0) >=# g:lightline_thin_width',
 \    'filetype': '!IsWeirdBuffer() && winwidth(0) >=# g:lightline_thin_width',
 \ }


let g:lightline_wide_width = 100
let g:lightline_thin_width = 80

function! IsWeirdBuffer()
   return &filetype =~# '\v(startify|denite)'
endfunction

function! LightlineModified()
   return (&modified || !&modifiable) && !IsWeirdBuffer() ? "\uF040" : ''
endfunction

function! LightlineReadonly()
   return &readonly && !IsWeirdBuffer() ? 'RO' : ''
endfunction

function! LightlineFileencoding()
   if IsWeirdBuffer()
      return ''

   elseif winwidth(0) >=# g:lightline_thin_width
      return &fileencoding !=# "" ? &fileencoding : &encoding " Always 'utf-8' in NeoVim
   else
      return ''
   endif
endfunction

if !exists('*WebDevIconsGetFileTypeSymbol')
   function! WebDevIconsGetFileTypeSymbol()
      return ''
   endfunction
   function! WebDevIconsGetFileFormatSymbol()
      return ''
   endfunction
endif

function! LightlineFileformat()
   if IsWeirdBuffer()
      return ''

   elseif winwidth(0) >=# g:lightline_wide_width
      return WebDevIconsGetFileFormatSymbol() . &fileformat
   elseif winwidth(0) >=# g:lightline_thin_width
      return WebDevIconsGetFileFormatSymbol()
   else
      return ''
   endif
endfunction

function! LightlineFiletype()
   if IsWeirdBuffer()
      return ''
   endif

   return winwidth(0) >=# g:lightline_thin_width
    \ ? (strlen(&filetype) ? WebDevIconsGetFileTypeSymbol() . &filetype : "\u0078 none")
    \ : (strlen(&filetype) ? WebDevIconsGetFileTypeSymbol() : "\u0078 ")
endfunction

" See: <https://gist.github.com/pocari/84c78efa38b5c2fc1f659d1aac3face8>
function! LightlineMode()
   if &ft == 'denite'
      let mode_str = substitute(denite#get_status_mode(), "-\\| ", "", "g")
      call lightline#link(tolower(mode_str[0]))
      return mode_str
   else
      return winwidth('.') > 60 ? lightline#mode() : ''
   endif
endfunction

let g:lightline_buffer_excludes = ['vimfiler']

" #### Syntastic
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

let g:syntastic_error_symbol = "\u2717"
let g:syntastic_warning_symbol = "\u26A0"


let g:syntastic_mode_map = { 'mode': 'active',
 \    'active_filetypes': [],
 \    'passive_filetypes': []
 \ }

let g:syntastic_ocaml_checkers = ['merlin']

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0
let g:syntastic_id_checkers = 1

"" #### vim-easytags
"set tags=./tags;
"let g:easytags_dynamic_files = 2
"let g:easytags_resolve_links = 1
"let g:easytags_async = 1
"
"let g:easytags_include_members = 1
"let g:easytags_auto_highlight = 0
"
"" for YouCompleteMe (and parse .h files as C, not C++)
"let g:easytags_opts = [
"\     '--fields=+l'
"\   , '--langmap=c:.c.h'
"\  ]
"
"" #### Tagbar
"let g:tagbar_left = 1
"let g:tagbar_width = 50
"let g:tagbar_zoomwidth = 105
"let g:tagbar_expand = 1
"let g:tagbar_iconchars = ['▸', '▾']
"
"" #### YouCompleteMe
"let g:ycm_collect_identifiers_from_tags_files = 1
"
"let g:ycm_complete_in_comments = 1
"let g:ycm_complete_in_strings = 1
"
"let g:ycm_add_preview_to_completeopt = 1
"let g:ycm_autoclose_preview_window_after_completion = 1
"let g:ycm_autoclose_preview_window_after_insertion = 1
"
"" This is a duplication of the default values, since they don't exist until runtime, and thus can't
"" be appended to without an `after` file.
"" (See: https://github.com/Valloric/YouCompleteMe/issues/1569)
"
""let g:ycm_filetype_blacklist['nerdtree'] = 1
"let g:ycm_filetype_blacklist = {
"\     'tagbar': 1
"\   , 'qf': 1
"\   , 'notes': 1
"\   , 'markdown': 1
"\   , 'unite': 1
"\   , 'text': 1
"\   , 'vimwiki': 1
"\   , 'pandoc': 1
"\   , 'infolog': 1
"\   , 'mail' : 1
"\
"\   , 'nerdtree' : 1
"\  }

" #### vim-focus-autocmd
let g:focau = {}

" Need to figure out the Hyper.app codes for cursor-changing
"let g:focau.cursors = ['', '', '']

" 'clipboard' appears to be broken (see amerlyq/vim-focus-autocmd#4)
"let g:focau.widgets = ['clipboard', 'buffers', 'number']
let g:focau.widgets = []


" #### vim-move
" Use <C-j> and <C-k> in normal and visual mode to move lines around
let g:move_key_modifier = 'C'

" #### Deoplete
let g:deoplete#complete_method = "omnifunc"
let g:deoplete#enable_at_startup = 1
let g:deoplete#enable_refresh_always = 1

let g:deoplete#sources = {}
let g:deoplete#omni#functions = {}
let g:deoplete#omni#input_patterns = {}

let g:deoplete#omni#functions.javascript = ['tern#Complete']
let g:deoplete#sources['javascript.jsx'] = ['file', 'ultisnips', 'ternjs']
let g:deoplete#sources#ternjs#docs = 1
let g:deoplete#sources#ternjs#types = 1
let g:deoplete#sources#ternjs#depths = 1
let g:deoplete#sources#ternjs#case_insensitive = 1
let g:deoplete#sources#ternjs#include_keywords = 1

let g:deoplete#omni#input_patterns.ocaml = '[^. *\t]\.\w*|\s\w*|#'


" #### SuperTab
" FIXME: .... more
let g:SuperTabDefaultCompletionType = "context"
let g:SuperTabContextDefaultCompletionType = "<c-p>"
augroup supertab-config | au!
   au FileType javascript call SuperTabSetDefaultCompletionType("<c-x><c-o>")
   au FileType ocaml      call SuperTabSetDefaultCompletionType("<c-x><c-o>")
augroup END


let g:SuperTabCrMapping = 1 " won't have any effect, if there's a mapping with <cr> in it
let g:SuperTabLongestEnhanced = 1
let g:SuperTabLongestHighlight = 1
let g:SuperTabClosePreviewOnPopupClose = 1

" #### UltiSnips
" FIXME: .... more

" #### vim-hardtime
let g:hardtime_default_on = 1
let g:hardtime_showmsg = 1
let g:hardtime_timeout = 2500
let g:hardtime_ignore_quickfix = 1
let g:hardtime_allow_different_key = 1

let g:list_of_insert_keys = []

let g:hardtime_ignore_buffer_patterns = [ "[denite]" ]

" #### vim-gitgutter
let g:gitgutter_realtime = 1
let g:gitgutter_eager = 1

" #### merlin
let g:merlin_completion_arg_type = "always"
let g:merlin_type_history_auto_open = 2

"let g:gundo_width = 25
"let g:gundo_preview_bottom = 1
"let g:gundo_help = 0
"let g:gundo_close_on_revert = 1
"
"let g:sparkupArgs = '--indent-spaces=3 --no-last-newline --post-tag-guides'
"
""let g:nerdtree_tabs_autofind=1 " This seems to fail. Some error about ‘dictionary: reveal.‘
"
"let g:tex_flavor = 'latex'

" filnxtToO → ilxstToOIF
" (Last `shm+=I` disables the :intro message.)
set shortmess-=f shm-=n shm+=s shm +=F shm+=I
