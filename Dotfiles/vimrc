if !has('nvim')
   " Duplicate NeoVim's changes to Vim defaults, incase I start classic Vim for some reason
   " (See :help nvim-defaults)
   filetype plugin indent on

   set autoread autoindent backspace=indent,eol,start belloff=all complete-=i display=lastline \
       history=10000 hlsearch incsearch nolangremap nocompatible nrformats=bin,hex ruler \
       sessionoptions-=options showcmd tabpagemax=50 ttyfast viminfo+=",!" wildmenu

   set encoding=utf-8
endif

set hidden
set textwidth=100 wrapmargin=3
set cursorline colorcolumn=+1,+2,+3
set number signcolumn=auto
set smarttab expandtab tabstop=8 softtabstop=8 shiftwidth=3 shiftround
set smartcase ignorecase
set laststatus=1 cmdheight=2 " higher cmdheight for deoplete / echodoc.vim

set nowrap
set listchars+=tab:\ ─
set breakindent showbreak=⥟\ \   " For `set wrap linebreak`

set ignorecase smartcase gdefault
let mapleader = " "
let maplocalleader = ","

set scrolloff=3
set title

set completeopt=longest,menuone,preview

set conceallevel=1

if (has("termguicolors"))
   set termguicolors
endif

syntax on


" `vim-plug` installation & package-loading
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

source ~/.vim/packages.vim

if has("gui_vimr")
   colorscheme nord
else
   colorscheme slate
endif


" Command-line tab completion
set wildmode=list:longest,list:full
set wildignore+=*.o,*.obj,.git,*.class,.svn

if has("mouse")
   set mouse=a

   if !has('nvim') && &term == 'screen'
      " tmux knows the extended mouse mode
      set ttymouse=xterm2
   endif

   if !has('nvim') && v:version >= 704 && &term =~ '^screen'
      " Odds are good that this is a modern tmux, so let's pick the best mouse-handling mode.
      set ttymouse=sgr
   endif

   " These break the Markdown plugin o_O
  "map <ScrollWheelUp> <C-Y>
  "map <ScrollWheelDown> <C-E>
endif

if executable("ag")
  "set grepprg=ag\ --nogroup\ --nocolor
   set grepprg=ag\ --vimgrep\ --nocolor
   let g:ctrlp_user_command = 'ag %s -l --nocolor --hidden -g ""'
endif

" Fill these functions to tie other plugins into focus-mode
function! s:goyo_enter()
   " ...
endfunction

function! s:goyo_leave()
   " ...
endfunction

autocmd! User GoyoEnter nested call <SID>goyo_enter()
autocmd! User GoyoLeave nested call <SID>goyo_leave()

"autocmd FileType c,cpp nested :TagbarOpen
"
"
" === Styles ===
" This toggles the hilighting of trailing-whitespace.
fun! ToggleExtraWhitespace()

   if exists('b:ews') && b:ews == 1
     "echom "Disabling trailing-whitespace hilighting in" bufnr('%') "..."
      let b:ews=0
      call HighlightExtraWhitespace()

     "echom "-- Removing ExtraWhitespace augroup"
      au!      ExtraWhitespace
      augroup! ExtraWhitespace

   else
     "echom "Enabling trailing-whitespace hilighting in" bufnr('%') "..."
      let b:ews=1
      call HighlightExtraWhitespace()

     "echom "-- Adding ExtraWhitespace augroup"
      augroup  ExtraWhitespace
         au!
         au BufEnter    * match ExtraWhitespace /\s\+$/
         au InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
         au InsertLeave * match ExtraWhiteSpace /\s\+$/
      augroup END

      if mode() == "i" | do ExtraWhitespace InsertEnter | else | do ExtraWhitespace BufEnter | endif

   endif
endfun

" This adds (or removes) the actual hilighting to your ColourScheme. (It's must be re-called every
" time you toggle hilighting, or change your scheme.)
fun! HighlightExtraWhitespace()
   if exists('b:ews') && b:ews == 1
     "echom "-- Adding ExtraWhitespace hilighting"
      highlight ExtraWhitespace ctermbg=red guibg=red
   else
     "echom "-- Removing ExtraWhitespace hilighting"
      highlight clear ExtraWhitespace
   endif
endfun
au ColorScheme * call HighlightExtraWhitespace()

" (Uncomment the following line if you want trailing-whitespace hilighted by default!)
bufdo call ToggleExtraWhitespace() | au BufAdd * call ToggleExtraWhitespace()

"if &diff
"   let g:color_coded_enabled = 0
"endif

" === Mappings ===
" Thanks, Damian. http://ell.io/i6io1
nnoremap ; :

" Fuck '.
nnoremap ' `
nnoremap ` '

" These make movement commands “work” with `o`, such as `3o` to insert inject lines and switch to insert mode.
"nnoremap o o<Esc>S        " ... unfortunately, they break yanking.
"nnoremap O O<Esc>'[S

" See `:help Y`
map Y y$

nnoremap  <Leader>w <C-W>

noremap <C-w>E :SyntasticCheck<CR> :SyntasticToggleMode<CR>

" fzf open-file
nnoremap <Leader>o :Files<cr>

noremap  <silent> <C-S>         :update<CR>
vnoremap <silent> <C-S>    <C-C>:update<CR>
inoremap <silent> <C-S>    <C-O>:update<CR>
noremap           <C-W>         :confirm quit<CR>
vnoremap          <C-W>    <C-C>:confirm quit<CR>
inoremap          <C-W>    <C-O>:confirm quit<CR>

noremap  <silent> <C-K>         :nohlsearch<CR>
vnoremap <silent> <C-K>    <C-C>:nohlsearch<CR>
inoremap <silent> <C-K>    <C-O>:nohlsearch<CR>


"noremap  <silent> <F1>          :NERDTreeTabsToggle<Return>
"inoremap <silent> <F1>     <C-O>:NERDTreeTabsToggle<Return>
"vnoremap <silent> <F1>     <Esc>:NERDTreeTabsToggle<Return>
"noremap  <silent> <F2>          :GundoToggle<Return>
"inoremap <silent> <F2>     <C-O>:GundoToggle<Return>
"vnoremap <silent> <F2>     <Esc>:GundoToggle<Return>
"noremap  <silent> <F3>          :TagbarToggle<Return>
"inoremap <silent> <F3>     <C-O>:TagbarToggle<Return>
"vnoremap <silent> <F3>     <Esc>:TagbarToggle<Return>

noremap  <silent> <F8>          :set spell!<Return>
inoremap <silent> <F8>     <C-O>:set spell!<Return>
vnoremap <silent> <F8>     <Esc>:set spell!<Return>
"
"call togglebg#map("<F5>")
"
" F9 to toggle focus-mode
nmap <silent> <F9>  :Goyo<cr>
imap <silent> <F9>  <C-O><F9>

" F10 to toggle hilighting extra whitespace
nmap <silent> <F10> :call ToggleExtraWhitespace()<cr>
imap <silent> <F10> <C-O><F10>

" F11 to toggle the signcolumn (‘gutter’)
nmap <silent> <F11> :exec &signcolumn == "no" ? "set signcolumn=yes" : "set signcolumn=no"<cr>
imap <silent> <F11> <C-O><F11>

" F12 to toggle hilight, Shift-F12 to clear search register
nmap <silent> <F12> :silent set invhls<CR>
imap <silent> <F12> <C-O><F12>
map  <silent> <S-F12> :let @/ = @_<CR>
imap <silent> <S-F12> <C-O><S-F12>

" Toggle conealing with space-c
map <Leader>c :exec &conceallevel ? "set conceallevel=0" : "set conceallevel=1"<CR>

autocmd BufLeave,FocusLost * silent! wall

"" gist-vim defaults
"if has("mac")
"  let g:gist_clip_command = 'pbcopy'
"elseif has("unix")
"  let g:gist_clip_command = 'xclip -selection clipboard'
"endif
"let g:gist_detect_filetype = 1
"let g:gist_open_browser_after_post = 1

set undofile
set undolevels=10000

" Directories for swp files
set backupdir=~/.vim/backup
set directory=~/.vim/backup
set undodir=~/.vim/undo,\ .

" suggested by vim-gitgutter
set updatetime=250

"set statusline=%<%f\ %h%m%r%{fugitive#statusline()}%=%-14.(%l,%c%V%)\ %P

"" The markdown.vim ftplugin supports ```this kind of syntax-hilighting fence
"let g:markdown_fenced_languages = [ 'c', 'objc', 'make', 'sh'
"                                 \, 'html', 'css', 'xml'
"                                 \, 'js=javascript', 'coffee', 'json'
"                                 \, 'ruby', 'python', 'lisp', 'scheme', 'haskell' ]


" === Filetype extension ===
augroup filetypes
   au!
   autocmd BufNewFile,BufFilePre,BufRead *.md
    \ set filetype=markdown

   autocmd BufNewFile,BufFilePre,BufRead {Gemfile,Rakefile,Vagrantfile,Thorfile,config.ru}
    \ set filetype=ruby

   autocmd BufNewFile,BufFilePre,BufRead *.pegjs
    \ set filetype=pegjs

   autocmd BufNewFile,BufFilePre,BufRead {.profile,.zprofile,.zlogin,.zlogout,.zshrc,.zshenv}
    \ set filetype=zsh
augroup END

au FileType gitcommit set wrap tw=0

" To fold by indentation in CoffeeScript files, but don't enable by default. (`zi` to enable)
autocmd BufNewFile,BufReadPost *.coffee setl foldmethod=indent nofoldenable

augroup ocamlmaps
   au!
   au FileType ocaml nmap <LocalLeader>*   <Plug>(MerlinSearchOccurrencesForward)
   au FileType ocaml nmap <LocalLeader>#   <Plug>(MerlinSearchOccurrencesBackward)
   au FileType ocaml nmap <LocalLeader>r   <Plug>(MerlinRename)
   au FileType ocaml nmap <LocalLeader>R   <Plug>(MerlinRenameAppend)

   " I don't know why Merlin doesn't ship with a mapping for these.
   au FileType ocaml nmap <LocalLeader>y  :MerlinYankLatestType<cr>
   au FileType ocaml nmap <LocalLeader>l  :MerlinLocate<cr>

augroup END

" FIXME: idk how to make these non-global, though. They should really be au-filetype'd.
let g:merlin_textobject_grow   = 'm'
let g:merlin_textobject_shrink = 'M'

"" === Plugins ===
"call arpeggio#load()

" #### Goyo
let g:goyo_width = 100

"let NERDChristmasTree = 1
"let NERDTreeShowBookmarks = 1
"let NERDTreeBookmarksFile = '.NERDTreeBookmarks'
"let NERDTreeMouseMode = 2
"let NERDTreeSortOrder = ['\/$', '\.h$', '*']
"let NERDTreeWinPos = 'right'
"let NERDTreeMinimalUI = 1
"let NERDTreeDirArrows = 1
"let NERDTreeWinSize = 25
"
"let NERDBlockComIgnoreEmpty = 0
"let NERDSpaceDelims = 1
"let NERDCompactSexyComs = 1
"let NERDDefaultNesting = 0
"
"let g:CommandTMaxCachedDirectories = 0
"let g:CommandTMaxHeight = 10
"let g:CommandTMatchWindowReverse = 1
"let g:CommandTScanDotDirectories = 1  " `:set wildignore` handles this better.
"
""let g:CoffeeAutoTagIncludeVars=1
"
"" #### vim-javascript
"let g:javascript_plugin_jsdoc = 1
"let g:javascript_plugin_flow  = 1
"
"let g:javascript_conceal_function         = "ƒ"
"let g:javascript_conceal_this             = "@"
"let g:javascript_conceal_arrow_function   = "⇒"


" #### Syntastic
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

let g:syntastic_error_symbol = "\u2717"
let g:syntastic_warning_symbol = "\u26A0"


let g:syntastic_mode_map = { 'mode': 'active',
 \    'active_filetypes': [],
 \    'passive_filetypes': []
 \ }

let g:syntastic_ocaml_checkers = ['merlin']

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0
let g:syntastic_id_checkers = 1

"" #### vim-easytags
"set tags=./tags;
"let g:easytags_dynamic_files = 2
"let g:easytags_resolve_links = 1
"let g:easytags_async = 1
"
"let g:easytags_include_members = 1
"let g:easytags_auto_highlight = 0
"
"" for YouCompleteMe (and parse .h files as C, not C++)
"let g:easytags_opts = [
"\     '--fields=+l'
"\   , '--langmap=c:.c.h'
"\  ]
"
"" #### Tagbar
"let g:tagbar_left = 1
"let g:tagbar_width = 50
"let g:tagbar_zoomwidth = 105
"let g:tagbar_expand = 1
"let g:tagbar_iconchars = ['▸', '▾']
"
"" #### YouCompleteMe
"let g:ycm_collect_identifiers_from_tags_files = 1
"
"let g:ycm_complete_in_comments = 1
"let g:ycm_complete_in_strings = 1
"
"let g:ycm_add_preview_to_completeopt = 1
"let g:ycm_autoclose_preview_window_after_completion = 1
"let g:ycm_autoclose_preview_window_after_insertion = 1
"
"" This is a duplication of the default values, since they don't exist until runtime, and thus can't
"" be appended to without an `after` file.
"" (See: https://github.com/Valloric/YouCompleteMe/issues/1569)
"
""let g:ycm_filetype_blacklist['nerdtree'] = 1
"let g:ycm_filetype_blacklist = {
"\     'tagbar': 1
"\   , 'qf': 1
"\   , 'notes': 1
"\   , 'markdown': 1
"\   , 'unite': 1
"\   , 'text': 1
"\   , 'vimwiki': 1
"\   , 'pandoc': 1
"\   , 'infolog': 1
"\   , 'mail' : 1
"\
"\   , 'nerdtree' : 1
"\  }

" #### vim-focus-autocmd
let g:focau = {}

" Need to figure out the Hyper.app codes for cursor-changing
"let g:focau.cursors = ['', '', '']

" 'clipboard' appears to be broken (see amerlyq/vim-focus-autocmd#4)
"let g:focau.widgets = ['clipboard', 'buffers', 'number']
let g:focau.widgets = []

" #### Deoplete
let g:deoplete#complete_method = "omnifunc"
let g:deoplete#enable_at_startup = 1
let g:deoplete#enable_refresh_always = 1

let g:deoplete#sources = {}
let g:deoplete#omni#functions = {}
let g:deoplete#omni#input_patterns = {}

let g:deoplete#omni#functions.javascript = ['tern#Complete']
let g:deoplete#sources['javascript.jsx'] = ['file', 'ultisnips', 'ternjs']
let g:deoplete#sources#ternjs#docs = 1
let g:deoplete#sources#ternjs#types = 1
let g:deoplete#sources#ternjs#depths = 1
let g:deoplete#sources#ternjs#case_insensitive = 1
let g:deoplete#sources#ternjs#include_keywords = 1

let g:deoplete#omni#input_patterns.ocaml = '[^. *\t]\.\w*|\s\w*|#'


" #### SuperTab
" FIXME: .... more
let g:SuperTabDefaultCompletionType = "context"
let g:SuperTabContextDefaultCompletionType = "<c-p>"
au FileType javascript call SuperTabSetDefaultCompletionType("<c-x><c-o>")
au FileType ocaml      call SuperTabSetDefaultCompletionType("<c-x><c-o>")


let g:SuperTabCrMapping = 1 " won't have any effect, if there's a mapping with <cr> in it
let g:SuperTabLongestEnhanced = 1
let g:SuperTabLongestHighlight = 1
let g:SuperTabClosePreviewOnPopupClose = 1

" #### UltiSnips
" FIXME: .... more
let g:UltiSnipsExpandTrigger="<C-j>"


" #### vim-gitgutter
let g:gitgutter_realtime = 1
let g:gitgutter_eager = 1

" #### merlin
let g:merlin_completion_arg_type = "always"
let g:merlin_type_history_auto_open = 2

" ## added by OPAM user-setup for vim / base ## 93ee63e278bdfc07d1139a748ed3fff2 ## you can edit, but keep this line
let s:opam_share_dir = system("opam config var share")
let s:opam_share_dir = substitute(s:opam_share_dir, '[\r\n]*$', '', '')

let s:opam_configuration = {}

function! OpamConfOcpIndent()
  execute "set rtp^=" . s:opam_share_dir . "/ocp-indent/vim"
endfunction
let s:opam_configuration['ocp-indent'] = function('OpamConfOcpIndent')

function! OpamConfOcpIndex()
  execute "set rtp+=" . s:opam_share_dir . "/ocp-index/vim"
endfunction
let s:opam_configuration['ocp-index'] = function('OpamConfOcpIndex')

function! OpamConfMerlin()
  let l:dir = s:opam_share_dir . "/merlin/vim"
  execute "set rtp+=" . l:dir
endfunction
let s:opam_configuration['merlin'] = function('OpamConfMerlin')

let s:opam_packages = ["ocp-indent", "ocp-index", "merlin"]
let s:opam_check_cmdline = ["opam list --installed --short --safe --color=never"] + s:opam_packages
let s:opam_available_tools = split(system(join(s:opam_check_cmdline)))
for tool in s:opam_packages
  " Respect package order (merlin should be after ocp-index)
  if count(s:opam_available_tools, tool) > 0
    call s:opam_configuration[tool]()
  endif
endfor
" ## end of OPAM user-setup addition for vim / base ## keep this line

"let g:gundo_width = 25
"let g:gundo_preview_bottom = 1
"let g:gundo_help = 0
"let g:gundo_close_on_revert = 1
"
"let g:sparkupArgs = '--indent-spaces=3 --no-last-newline --post-tag-guides'
"
""let g:nerdtree_tabs_autofind=1 " This seems to fail. Some error about ‘dictionary: reveal.‘
"
"let g:tex_flavor = 'latex'

" filnxtToO → ilxstToOIF
" (Last `shm+=I` disables the :intro message.)
set shortmess-=f shm-=n shm+=s shm +=F shm+=I
